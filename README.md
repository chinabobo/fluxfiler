# fluxfiler

Fast and efficient file transfers over a network that includes server-side and client-side code for managing concurrent file transfers of large files with low latency and high throughput.

## Features

1. Supports batch uploading and downloading of files, as well as md5 verification.
2. Supports viewing of file lists.
3. Supports resumption of downloads and uploading of files from breakpoints.
4. Supports upload and download of large file slices.
5. Supports retransmission of failed slices, as well as retry of download if slices fail.
6. Supports control of the maximum number of goroutines for each file upload and download.
7. The server reads the saved file directory, bound IP, and port information from the configuration file.

## Description of the process

1. When uploading a file, the first step is to determine whether the file is larger than 1M. If the file is less than 1M, no segmentation is necessary, and the entire file is sent to the server through an HTTP request for storage.

2. If the file is larger than 1M, the first step is to determine whether the file has been uploaded in part. This is determined by searching the current directory for a corresponding metadata file. If none is found, the file is considered a new upload, and if a part has been uploaded, it is considered a breakpoint continuation.

3. If the file is a new upload, the file is calculated, such as by dividing it into multiple segments, and a unique upload UUID is generated as an upload identifier, and this data is saved to a local file (creates an hidden file with the extension ".uploading").

4. At the same time, a request is sent to the server to create a UUID directory in the storage directory, used to store the segmentation files later. At the same time, a metadata file is generated by the server.

5. If the file is a breakpoint continuation, the client requests the server to determine which segments of the file have not been uploaded. The server can identify which segments have not been uploaded by using the sequence numbers saved in the storage directory along with the file metadata. The server then sends these segment numbers back to the client. For example, if there are 1, 5, 6, and 7 segments that have not been uploaded, the server only needs to send 1, 5, and -1 to indicate that the first and fifth segments and the last segment have not been uploaded successfully.

6. Before uploading, a goroutine is launched to retry failed segments. It continuously reads the segmentation data from the RetryChannel, if none is available, it blocks. If there is a segment, it is reuploaded, and if it fails again, it is sent to the RetryChannel, functioning as a queue.

7. The file is read, and if it is a breakpoint continuation, the client can specify an offset to skip specified segments. The file is read every 1M, and the server checks whether the segment has been uploaded. If it has been uploaded, the server does not need to upload it again, and it can be skipped. Otherwise, a goroutine is created for asynchronous upload.

8. When all goroutines have completed, indicating that all segments have been uploaded, a request is sent to the server to inform it that the segment has been uploaded successfully. The server then sets the file status to active.

## Core of this design

1. File Segmentation: The large file is segmented into pieces of 1M in size. For example, if a 5M file is uploaded, it will be segmented into 6 pieces with file names of 0, 1, 2, 3, 4, and 5. The server creates a folder with a UUID for each of the 5 segments and records a metadata file that contains the original information such as the directory, file slice size, file size, and file md5. For small files less than 1M, the file is not segmented and treated as a single file with a file name ending in ".slice".

2. Breakpoint resumption and breakpoint download: When starting to upload a file, a hidden file is created as the upload metadata file. For example, if the file name is "file.txt", the hidden file name is ".file.txt.uploading". The file contains the file metadata information such as the upload UUID, file size, and file md5. If the upload is completed, the hidden file is deleted to indicate that the entire file has been uploaded. If the upload is interrupted during the process, the next time the file is uploaded, the hidden file is detected and the file is recognized as an incomplete file. The server is requested to determine which segments of the file are missing. For example, if the file has 1, 2, 3, 4, and 5 segments, the server responds that it received only 1, 3, and 5 segments, so the missing segments of 0 and 2 are retransmitted.

3. Retry of failed segments: The upload and download structures each have a RetryChannel, which is a channel type for segment structures. When a segment is uploaded or downloaded unsuccessfully, the segment is sent to this channel. A goroutine is started to read data from this channel and retry the failed segment.

4. Concurrent upload or download: Concurrent upload and download is implemented using goroutines in Go. The goroutine is executed in units of file slices, and a channel is used to control the number of goroutines running. A synchronization signal is used to control whether all goroutines have completed.

## Usage

### server

```shell
$ go run main.go 
```

### client

```shell
$ go run main.go --help
```

get all usage

```shell
# upload
$ go run main.go --action upload --uploadFilepaths /User/herbert/test/upload/aa.pdf

# List of files uploaded
$ go run main.go --action list

# download
$ go run main.go --action download --downloadDir /User/herbert/test/download --downloadFilenames aa.pdf
```

## Possible improvements

1. The algorithm for calculating the sequence number that needs to be retransmitted can be improved further. For example, it can be represented in the form of 1-3, 5-9, etc., so that the sequence number can be more accurately transmitted.

2. The current MD5 calculation algorithm calculates the entire file, but actually, each segment of the file can be assigned an MD5 hash. This way, the MD5 sum of the entire file need not be calculated again at the end, reducing the number of reads performed for IO.

3. When downloading a file, a dedicated 空洞文件 can be created with a specified size. After receiving each segment of the file, it can be written to the new file at the specified offset, avoiding the final merge process's IO.

## License

[MIT © chinabobo](https://github.com/chinabobo/fluxfiler/blob/main/LICENSE)